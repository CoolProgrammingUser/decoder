<!doctype html>
<html>
	<head>
		<title>
			Decoder
		</title>
		<base target="_blank">
		<script src="https://epicenterprograms.github.io/standards/behavior/general.js"></script>
		<script>
			var S = Standards.general;



			// handles Morse Code stuff

			var telegraph = new S.Sound({ waveform: "square" });
			S.listen("morseCodeText", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("morseCodeText", "keyup", function (event) {
				if (event.key == "Enter") {
					toMorseCode();
				}
			});
			function toMorseCode() {
				if (S.getId("morseCodeText").value.trim() != "") {
					let translation = "";
					let note = "a";
					if (S.getId("morseCodeText").value.search(/^[.\-_ ]+$/) > -1) {  // if the message is written in Morse Code
						translation = S.getId("morseCodeText").value.trim();
						translation = translation.replace(/_/g, "-");
						translation = translation.replace(/ /g, "    ");
						translation = translation.replace(/(\.|-)/g, "$1 ");
						translation = translation.trim();
					} else {
						S.getId("morseCodeText").value.trim().toLowerCase().split("").forEach(function (character) {
							switch (character) {
								case "a":
									translation += ". -";
									break;
								case "b":
									translation += "- . . .";
									break;
								case "c":
									translation += "- . - .";
									break;
								case "d":
									translation += "- . .";
									break;
								case "e":
									translation += ".";
									break;
								case "f":
									translation += ". . - .";
									break;
								case "g":
									translation += "- - .";
									break;
								case "h":
									translation += ". . . .";
									break;
								case "i":
									translation += ". .";
									break;
								case "j":
									translation += ". - - -";
									break;
								case "k":
									translation += "- . -";
									break;
								case "l":
									translation += ". - . .";
									break;
								case "m":
									translation += "- -";
									break;
								case "n":
									translation += "- .";
									break;
								case "o":
									translation += "- - -";
									break;
								case "p":
									translation += ". - - .";
									break;
								case "q":
									translation += "- - . -";
									break;
								case "r":
									translation += ". - .";
									break;
								case "s":
									translation += ". . .";
									break;
								case "t":
									translation += "-";
									break;
								case "u":
									translation += ". . -";
									break;
								case "v":
									translation += ". . . -";
									break;
								case "w":
									translation += ". - -";
									break;
								case "x":
									translation += "- . . -";
									break;
								case "y":
									translation += "- . - -";
									break;
								case "z":
									translation += "- - . .";
									break;
								case " ":
									translation += "    ";
									break;
								case "0":
									translation += "- - - - -";
									break;
								case "1":
									translation += ". - - - -";
									break;
								case "2":
									translation += ". . - - -";
									break;
								case "3":
									translation += ". . . - -";
									break;
								case "4":
									translation += ". . . . -";
									break;
								case "5":
									translation += ". . . . .";
									break;
								case "6":
									translation += "- . . . .";
									break;
								case "7":
									translation += "- - . . .";
									break;
								case "8":
									translation += "- - - . .";
									break;
								case "9":
									translation += "- - - - .";
									break;
								case ".":
									translation += ". - . - . -";
									break;
								case "?":
									translation += ". . - - . .";
									break;
								case "!":
									translation += ["- . - . - -", "- - - ."][Math.round(Math.random())];
									break;
								case ",":
									translation += "- - . . - -";
									break;
								case "'":
									translation += ". - - - - .";
									break;
								case "(":
									translation += "- . - - .";
									break;
								case ")":
									translation += "- . - - . -";
									break;
								case ":":
									translation += "- - - . . .";
									break;
								case ";":
									translation += "- . - . - .";
									break;
								case '"':
									translation += ". - . . - .";
									break;
								case "/":
									translation += "- . . - .";
									break;
								case "+":
									translation += ". - . - .";
									break;
								case "-":
									translation += "- . . . . -";
									break;
								case "=":
									translation += "- . . . -";
									break;
								case "$":
									translation += ". . . - . . -";
									break;
								case "@":
									translation += ". - - . - .";
									break;
								case "_":
									translation += ". . - - . -";
									break;
								case "Ã±":
									translation += "- - . - -";
									break;
								default:
									translation += "*";
							}
							translation += "   ";
						});
					}
					translation = translation.replace(/\./g, note).trim();
					translation = translation.replace(/-/g, note + "--");
					translation = translation.replace(/\*/g, "a5-");
					telegraph.play(translation, { attack: 1, noteLength: 1000/S.getId("morseCodeSpeed").value, decay: 1 });
				}
			}
			S.listen("morseCodeSpeed", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("morseCodeSpeed", "change", function () {
				this.value = this.value.trim();
				if (this.value == "" || S.getType(Number(this.value)) != "Number" || Number(this.value) < 1) {
					this.value = 15;
				}
			});
			S.listen("randomMorseCode", "click", function () {
				if (!telegraph.playing) {
					let text = S.getId("morseCodeText");
					text.value = "";
					text.value += ["I am ", "You are ", "We are ", "Morse Code is ", "This website is "][Math.floor(Math.random() * 5)];
					text.value += ["super ", "extremely ", "very ", "unmistakably ", "indisputably ", "most certainly ", "absolutely ", "without question ", "exceptionally "][Math.floor(Math.random() * 9)];
					text.value += ["amazing.", "awesome.", "cool.", "spectacular.", "sublime.", "lame. (Just kidding.)"][Math.floor(Math.random() * 6)];
					toMorseCode();
					text.value = "";
				}
			});



			// handles code font stuff

			S.listen("substitutedText", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("checkSpelling", "click", function () {
				if (this.checked) {
					S.getId("substitutedText").spellcheck = "true";
				} else {
					S.getId("substitutedText").spellcheck = "false";
				}
			});
			S.listen("fontSize", "change", function () {
				S.getId("substitutedText").style.fontSize = this.value + "em";
			});
			function changeFont(fontID) {
				switch (fontID) {
					case "normalFont":
						S.getId("substitutedText").style.fontFamily = "serif";
						break;
					case "badDuckFont":
						S.getId("substitutedText").style.fontFamily = "Bad Duck";
						break;
					case "kidtenuhfFont":
						S.getId("substitutedText").style.fontFamily = "KidtEnuhf";
						break;
					default:
						S.getId("substitutedText").style.fontFamily = "serif";
				}
			}
			S.listen("normalFont", "click", function () {
				if (this.checked) {
					changeFont(this.id);
					S.getId("substitutedText").placeholder = "Text";
				}
			});
			S.listen("badDuckFont", "click", function () {
				if (this.checked) {
					changeFont(this.id);
					S.getId("substitutedText").placeholder = "text";
				}
			});
			S.listen("kidtenuhfFont", "click", function () {
				if (this.checked) {
					changeFont(this.id);
					S.getId("substitutedText").placeholder = "tekst";
				}
			});
			S.listen("fontHelp", "focus", function () {
				this.selectedIndex = 0;  // clears the old selection (could be set to -1)
			});
			S.listen("fontHelp", "change", function () {
				switch (this.value) {
					case "Bad Duck":
						S.getId("badDuckHelp").className = "displayed";
						S.getId("kidtenuhfHelp").className = "";
						break;
					case "KidtEnuhf":
						S.getId("kidtenuhfHelp").className = "displayed";
						S.getId("badDuckHelp").className = "";
						break;
					default:
						S.getId("badDuckHelp").className = "";
						S.getId("kidtenuhfHelp").className = "";
				}
			});
			S.listen("reprintText", "click", function () {
				if (S.getId("substitutedText").value != "") {
					let reprintWindow = window.open();
					let style = reprintWindow.document.createElement("style");
					style.innerHTML =
						"body {padding:" + S.getId("fontSize").value / 2 + "em;}\n" +
						"@font-face {font-family:'Bad Duck'; src:url('https://coolprogramminguser.github.io/decoder/fonts/Bad Duck.ttf') format('truetype');}\n" +
						"@font-face {font-family:'KidtEnuhf'; src:url('https://coolprogramminguser.github.io/decoder/fonts/KidtEnuhf.ttf') format('truetype');}\n" +
						"@media(max-width:1000px) {body{font-size:3rem;}}" +
						"@media(prefers-color-scheme: dark) {body{background:black;color:white}}";  // if the dark theme is being used
					reprintWindow.document.head.appendChild(style);
					let text = reprintWindow.document.createElement("p");
					switch (S.getName("fonts", true).id) {
						case "normalFont":
							text.style.fontFamily = "serif";
							break;
						case "badDuckFont":
							text.style.fontFamily = "Bad Duck";
							break;
						case "kidtenuhfFont":
							text.style.fontFamily = "KidtEnuhf";
							break;
						default:
							text.style.fontFamily = "serif";
					}
					text.style.whiteSpace = "pre-line";
					text.style.fontSize = S.getId("fontSize").value + "em";
					text.textContent = S.getId("substitutedText").value;
					reprintWindow.document.body.appendChild(text);
				}
			});



			// handles letter code stuff

			S.listen("decrypted1", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encrypted1", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encode1", "click", function () {
				let alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
				let ALPHABET = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
				if (S.getId("decrypted1").value.trim() != "") {
					S.getId("encrypted1").value = S.getId("decrypted1").value.trim().replace(/\w|(?: \w)/g, function (match) {
						if (match[0] == " ") {
							if (alphabet.includes(match[1])) {
								match = String(2 * (alphabet.indexOf(match[1]) + 1));
								if (match.length < 2) {
									match = "0" + match;
								}
								match = match.splice(0, 1, match[0] == "0" ? "j" : alphabet[Number(match[0])-1]);
								match = match.splice(1, 1, match[1] == "0" ? "J" : ALPHABET[Number(match[1])-1]);
							} else if (ALPHABET.includes(match[1])) {
								match = String(2 * (ALPHABET.indexOf(match[1]) + 1));
								if (match.length < 2) {
									match = "0" + match;
								}
								match = match.splice(0, 1, match[0] == "0" ? "J" : ALPHABET[Number(match[0])-1]);
								match = match.splice(1, 1, match[1] == "0" ? "J" : ALPHABET[Number(match[1])-1]);
							}
						} else if (alphabet.includes(match)) {
							match = String(alphabet.indexOf(match) + 1);
							if (match.length < 2) {
								match = "0" + match;
							}
							match = match.splice(0, 1, match[0] == "0" ? "j" : alphabet[Number(match[0])-1]);
							match = match.splice(1, 1, match[1] == "0" ? "j" : alphabet[Number(match[1])-1]);
						} else if (ALPHABET.includes(match)) {
							match = String(ALPHABET.indexOf(match) + 1);
							if (match.length < 2) {
								match = "0" + match;
							}
							match = match.splice(0, 1, match[0] == "0" ? "J" : ALPHABET[Number(match[0])-1]);
							match = match.splice(1, 1, match[1] == "0" ? "j" : alphabet[Number(match[1])-1]);
						}
						return match;
					});
				} else if (S.getId("encrypted1").value.trim() != "") {
					S.getId("decrypted1").value = S.getId("encrypted1").value.trim().replace(/\w\w/g, function (match) {
						if (alphabet.includes(match[0])) {  // not a capital
							if (alphabet.includes(match[1])) {  // not preceded by a space
								match = match.splice(0, 1, match[0] == "j" ? "0" : String(alphabet.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "j" ? "0" : String(alphabet.indexOf(match[1]) + 1));
								match = alphabet[Number(match) - 1];
							} else if (ALPHABET.includes(match[1])) {  // preceded by a space
								match = match.splice(0, 1, match[0] == "j" ? "0" : String(alphabet.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "J" ? "0" : String(ALPHABET.indexOf(match[1]) + 1));
								match = " " + alphabet[Number(match) / 2 - 1];
							}
						} else if (ALPHABET.includes(match[0])) {  // a capital
							if (alphabet.includes(match[1])) {  // not preceded by a space
								match = match.splice(0, 1, match[0] == "J" ? "0" : String(ALPHABET.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "j" ? "0" : String(alphabet.indexOf(match[1]) + 1));
								match = ALPHABET[Number(match) - 1];
							} else if (ALPHABET.includes(match[1])) {  // preceded by a space
								match = match.splice(0, 1, match[0] == "J" ? "0" : String(ALPHABET.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "J" ? "0" : String(ALPHABET.indexOf(match[1]) + 1));
								match = " " + ALPHABET[Number(match) / 2 - 1];
							}
						}
						return match;
					});
				}
			});



			// handles password-protected code stuff

			S.listen("encryptionKey", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encryptionKey", "keyup", function (event) {
				if (event.key == "Enter") {
					S.getId("encode2").click();
				}
			});
			S.listen("decrypted2", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encrypted2", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encode2", "click", function () {
				if (S.getId("encryptionKey").value.trim() != "") {
					if (S.getId("advancedEncryption").checked) {
						let message = "";
						if (S.getId("decrypted2").value.trim() != "") {  // if encoding
							message = S.getId("decrypted2").value.trim();
							// reformats the message
							message = message.replace(/    /g, "\t");
							message = message.replace(/ +/g, " ");
							message = message.replace(/[A-Z]| [a-z]/g, function (match) {
								if (match.length == 1) {  // if it's a capital letter
									return " " + match;
								} else {  // if it's an uncapitalized beginning of a word
									return match[1].toUpperCase();
								}
							});
							/// all words are no longer separated by spaces but start with a capital
							/// words that started with a capital have their capital preceded by two spaces
							/// capitals within words (such as acronyms) have their capital preceded by one space
						} else if (S.getId("encrypted2").value.trim() != "") {  // if decoding
							message = S.getId("encrypted2").value.trim();
						}
						// sets the message length
						// (emojis are counted as two characters ordinarily)
						let length = 0;  // length of the message
						S.forEach(message, function () {
							length++;
						});
						length %= 100;  // prevents moving into awkward ranges in long messages
						// complicates the password
						let password = S.getId("encryptionKey").value.trim();
						let key = [];  // each code point of the password
						S.forEach(password, function (letter) {
							key.push(letter.codePointAt(0) + password.length + password.slice(-3).codePointAt(0) % 10 - 5);
						});
						key = key.slice(length % 5 + 1).concat(key.slice(0, length % 5 + 1));
						key[0] += length;
						key[key.length - 1] += length;
						// handles the encoding or decoding
						let keyIndex = 0;  // which letter of the password is currently being used
						let text = "";  // the result
						if (S.getId("decrypted2").value.trim() != "") {  // if encoding
							// encodes each letter
							S.forEach(message, function (character) {
								let number = character.codePointAt(0) + key[keyIndex];
								if (number > 128500) {  // handles one range of emojis
									text += String.fromCodePoint(number - 127744 + 154);
								} else if (number >= 127744) {  // handles another range of emojis
									text += String.fromCodePoint(number - 127744 + 180);
								} else if (number > 580 - 325 || number < 512 - 325) {  // converts everything else into emojis
									text += String.fromCodePoint(127900 + number);
								} else {  // helps make face emojis the most likely
									text += String.fromCodePoint(128000 + number + 325);
								}
								keyIndex++;
								if (keyIndex >= key.length) {
									keyIndex = 0;
								}
							});
							// displays the encrypted text
							S.getId("encrypted2").value = text;
						} else if (S.getId("encrypted2").value.trim() != "") {  // if decoding
							// decodes each emoji
							S.forEach(message, function (emoji) {
								let codePoint = emoji.codePointAt(0);
								if (codePoint <= 910) {  // handles another range of emojis
									codePoint += 127564;
								} else if (codePoint < 127900) {  // handles one range of emojis
									codePoint += 127590;
								} else if (codePoint < 128512 || codePoint > 128580) {  // converts everything else back into text
									codePoint -= 127900;
								} else {  // helps undo face emojis
									codePoint -= 128325;
								}
								codePoint -= key[keyIndex];
								if (codePoint < 0) {
									codePoint = 0;
								}
								text += String.fromCodePoint(codePoint);
								keyIndex++;
								if (keyIndex >= key.length) {
									keyIndex = 0;
								}
							});
							// reformats the message
							text = text.replace(/ ?[A-Z]/g, function (match) {
								if (match.length == 1) {  // if it's supposed to be an uncapitalized beginning of a word (if there's not a space before the capital)
									return " " + match.toLowerCase();
								} else {  // if it's supposed to be a capital letter (if there's a space before the capital)
									return match[1];
								}
							});
							// displays the decoded text
							S.getId("decrypted2").value = text;
						}
					} else {
						let key = S.getId("encryptionKey").value.trim();
						let keyIndex = 0;
						let text = "";
						if (S.getId("decrypted2").value.trim() != "") {
							let message = S.getId("decrypted2").value.trim();
							if (message[0] != " ") {
								message = " " + message;
							}
							message = message.replace(/(^|\W)([A-Z])/g, function (match, notLetter, capital) {
								return notLetter + "  " + capital;
							});
							message = message.replace(/[A-Z]/g, function (capital) {
								return " " + capital.toLowerCase();
							});
							message = message.replace(/ [a-z]/g, function (word) {
								return word[1].toUpperCase();
							});
							S.forEach(message, function (character) {
								let number = character.codePointAt(0) + key.codePointAt(keyIndex);
								if (number > 580 - 325 || number < 512 - 325) {
									text += String.fromCodePoint(127900 + number);
								} else {
									text += String.fromCodePoint(128000 + number + 325);
								}
								keyIndex++;
								if (keyIndex >= key.length) {
									keyIndex = 0;
								}
							});
							S.getId("encrypted2").value = text;
						} else if (S.getId("encrypted2").value.trim() != "") {
							let message = S.getId("encrypted2").value.trim();
							S.forEach(message.length / 2, function (number) {
								let codePoint = (message[message.length - number * 2] + message[message.length - number * 2 + 1]).codePointAt(0);
								if (codePoint < 128512 || codePoint > 128580) {
									codePoint -= 127900;
								} else {
									codePoint -= 128325;
								}
								codePoint -= key.codePointAt(keyIndex);
								if (codePoint < 0) {
									codePoint = 0;
								}
								text += String.fromCodePoint(codePoint);
								keyIndex++;
								if (keyIndex >= key.length) {
									keyIndex = 0;
								}
							});
							text = text.replace(/[A-Z]/g, function (capital) {
								return " " + capital.toLowerCase();
							});
							text = text.replace(/   [a-z]/g, function (word) {
								return word[3].toUpperCase();
							});
							text = text.replace(/  [a-z]/g, function (word) {
								return " " + word[2].toUpperCase();
							});
							if (text[0] == " ") {
								text = text.slice(1);
							}
							S.getId("decrypted2").value = text;
						}
					}
				} else {
					S.makeDialog("A password is required.");
				}
			});



			// handles symbol code stuff

			var symbols = [];
			var symbol = [];
			var drawASymbol = function () { };
			S.listen("decrypted3", "dblclick", function () {
				symbols = [];
				this.value = "";
				S.getId("encrypted3").innerHTML = "";
			});
			S.listen("encode3", "click", function () {
				if (S.getId("decrypted3").value.trim() != "") {
					S.getId("encrypted3").innerHTML = "";
					symbols = [];
					let message = S.getId("decrypted3").value;
					message = message.replace(/ +/g, " ");  // prevents more than one space at a time
					message = message.replace(/(\W)I(\W)/g, function (match, nonletter1, nonletter2) {  // uncapitalizes the word "I"
						return nonletter1 + "i" + nonletter2;
					});
					message = message.replace(/(?:^|\. )[A-Z](?!=[A-Z])/g, function (match) {  // uncapitalizes letters at the beginning of sentences
						return match.toLowerCase();
					});
					message = message.replace(/(,|\.|\?|!|:|;|\)|\/|"|]|}) (\w)/g, function (match, punctuation, letter) {  // removes spacing between punctuation & letters
						return punctuation + letter;
					});
					message = message.trim();
					let sh = Number(S.getId("symbolSize").value);  // symbol height
					let bu = sh / 4;  // base unit
					let hlw = bu / 6; // half line width (helps with padding the canvas to prevent lines from being cut in half at the edges)
					let u2 = bu * 2;  // 2 units
					let u3 = bu * 3;  // 3 units
					let u4 = bu * 4;  // 4 units
					function setSizes() {
						sh = Number(S.getId("symbolSize").value);
						bu = sh / 4;
						hlw = bu / 6;
						u2 = bu * 2;
						u3 = bu * 3;
						u4 = bu * 4;
					}
					let odd = true;
					let components = { gl: 0, dl: 0, va: 0, ha: 0, c: 0 };  // grid line, diagonal line, vertical arch, horizontal arch, circle
					function getDimensions(type, size, variation) {
						switch (type) {
							case "gl":
								if (size == "biggest") {
									if (variation) {
										return [0, 4];
									} else {
										return [4, 0];
									}
								} else if (size == "big") {
									if (variation) {
										return [0, 3];
									} else {
										return [3, 0];
									}
								} else {
									if (variation) {
										return [0, 1];
									} else {
										return [1, 0];
									}
								}
								break;
							case "dl":
								if (size == "biggest") {
									if (variation) {
										return [4, -4];
									} else {
										return [4, 4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, -3];
									} else {
										return [3, 3];
									}
								} else {
									if (variation) {
										return [1, -1];
									} else {
										return [1, 1];
									}
								}
								break;
							case "va":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [4, -4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [3, -3];
									}
								} else {
									if (variation) {
										return [1, 1];
									} else {
										return [1, -1];
									}
								}
								break;
							case "ha":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [-4, 4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [-3, 3];
									}
								} else {
									if (variation) {
										return [1, 1];
									} else {
										return [-1, 1];
									}
								}
								break;
							case "c":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [1 / 3, 1 / 3];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [1 / 3, 1 / 3];
									}
								} else {
									return [1, 1];
								}
								break;
							default:
								throw new TypeError("A symbol component had an unrecognized type.");
						}
					}
					function drawSymbol(symbolToReplace, indexToReplace) {
						let currentSymbol = JSON.parse(JSON.stringify(symbol));  // prevents changing the coordinates of the actual symbol
						let canvas = document.createElement("canvas");
						let c = canvas.getContext("2d");
						let minX = 2 * sh + 2 * hlw;
						let maxX = 0;
						setSizes();  // allows changing the symbol size
						S.forEach(currentSymbol, function (component) {  // converts the symbol coordinates from unit values to actual values
							component.coords = [hlw + component.coords[0] * bu, hlw + component.coords[1] * bu];
						});
						S.forEach(currentSymbol, function (component) {  // determines the smallest x-value used in the symbol
							let width = getDimensions(component.type, component.size, component.variation)[0] * bu;
							if (width < 0) {
								if (component.coords[0] + width < minX) {
									minX = component.coords[0] + width;
								}
							} else {
								if (component.coords[0] < minX) {
									minX = component.coords[0];
								}
							}
						});
						if (minX > hlw) {  // shifts the symbol components to the left edge of the canvas
							S.forEach(currentSymbol, function (component) {
								component.coords[0] = component.coords[0] - minX + hlw;
							});
						}
						S.forEach(currentSymbol, function (component) {  // determines the largest x-value used in the symbol
							let width = getDimensions(component.type, component.size, component.variation)[0] * bu;
							if (width < 0) {
								width = 0;
							}
							if (component.coords[0] + width > maxX) {
								maxX = component.coords[0] + width;
							}
						});
						c.canvas.width = maxX + hlw;  // makes the canvas width as big as the symbol
						c.canvas.height = sh + 2 * hlw;
						c.beginPath();
						c.lineWidth = 2 * hlw;
						c.lineCap = "round";
						if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {  // if the dark theme is being used
							c.strokeStyle = "white";
						}
						S.forEach(currentSymbol, function (component) {
							switch (component.type) {
								case "gl":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + u4);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1]);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + u3);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1]);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + bu);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1]);
										}
									}
									break;
								case "dl":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1] - u4);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1] + u4);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1] - u3);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1] + u3);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1] - bu);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1] + bu);
										}
									}
									break;
								case "va":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + u4 * 1.333,
												component.coords[0] + u4, component.coords[1] + u4 * 1.333,
												component.coords[0] + u4, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - u4 * 1.333,
												component.coords[0] + u4, component.coords[1] - u4 * 1.333,
												component.coords[0] + u4, component.coords[1]
											);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + u4,
												component.coords[0] + u3, component.coords[1] + u4,
												component.coords[0] + u3, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - u4,
												component.coords[0] + u3, component.coords[1] - u4,
												component.coords[0] + u3, component.coords[1]
											);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + bu * 1.333,
												component.coords[0] + bu, component.coords[1] + bu * 1.333,
												component.coords[0] + bu, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - bu * 1.333,
												component.coords[0] + bu, component.coords[1] - bu * 1.333,
												component.coords[0] + bu, component.coords[1]
											);
										}
									}
									break;
								case "ha":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + u4 * 1.333, component.coords[1],
												component.coords[0] + u4 * 1.333, component.coords[1] + u4,
												component.coords[0], component.coords[1] + u4
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - u4 * 1.333, component.coords[1],
												component.coords[0] - u4 * 1.333, component.coords[1] + u4,
												component.coords[0], component.coords[1] + u4
											);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + u4, component.coords[1],
												component.coords[0] + u4, component.coords[1] + u3,
												component.coords[0], component.coords[1] + u3
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - u4, component.coords[1],
												component.coords[0] - u4, component.coords[1] + u3,
												component.coords[0], component.coords[1] + u3
											);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + bu * 1.333, component.coords[1],
												component.coords[0] + bu * 1.333, component.coords[1] + bu,
												component.coords[0], component.coords[1] + bu
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - bu * 1.333, component.coords[1],
												component.coords[0] - bu * 1.333, component.coords[1] + bu,
												component.coords[0], component.coords[1] + bu
											);
										}
									}
									break;
								case "c":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0] + u4, component.coords[1] + u2);
											c.arc(component.coords[0] + u2, component.coords[1] + u2, u2, 0, 2 * Math.PI);
										} else {
											c.moveTo(component.coords[0] + 2 * hlw, component.coords[1] + hlw);
											c.arc(component.coords[0] + hlw, component.coords[1] + hlw, hlw, 0, 2 * Math.PI);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0] + u3, component.coords[1] + 1.5 * bu);
											c.arc(component.coords[0] + bu * 1.5, component.coords[1] + bu * 1.5, bu * 1.5, 0, 2 * Math.PI);
										} else {
											c.moveTo(component.coords[0] + 2 * hlw, component.coords[1] + hlw);
											c.arc(component.coords[0] + hlw, component.coords[1] + hlw, hlw, 0, 2 * Math.PI);
										}
									} else {
										c.moveTo(component.coords[0] + bu, component.coords[1] + bu / 2);
										c.arc(component.coords[0] + bu / 2, component.coords[1] + bu / 2, bu / 2, 0, 2 * Math.PI);
									}
									break;
								default:
									throw new TypeError("A symbol component had an unrecognized type.");
							}
						});
						c.stroke()
						let img = document.createElement("img");
						img.src = canvas.toDataURL();
						if (symbolToReplace) {
							S.insertAfter(img, symbolToReplace);
							S.removeSelf(symbolToReplace);
						} else {
							S.getId("encrypted3").appendChild(img);
						}
						currentSymbol = symbol;
						let currentIndex;
						if (indexToReplace === undefined) {
							currentIndex = symbols.length - 1;
						} else {
							currentIndex = indexToReplace;
						}
						img.addEventListener("click", function () {
							odd = true;
							createSubsymbol(currentSymbol, img, currentIndex);
						});
					}
					drawASymbol = drawSymbol;
					function createSubsymbol(character, symbolToReplace, indexToReplace) {
						components = { gl: 0, dl: 0, va: 0, ha: 0, c: 0 };
						if (odd) {
							symbol = [];
						}
						if (character === null) {  // if a capital subsymbol should be made
							components.gl = 1;
							components.c = 2;
						} else if (S.getType(character) == "String") {
							switch (character) {
								case " ":
									components.gl = 1;
									break;
								case "a":
									components.ha = 1;
									break;
								case "b":
									components.gl = 2;
									components.ha = 1;
									break;
								case "c":
									components.dl = 1;
									components.c = 1;
									break;
								case "d":
									components.dl = 2;
									break;
								case "e":
									components.dl = 1;
									break;
								case "f":
									components.gl = 3;
									break;
								case "g":
									components.ha = 2;
									break;
								case "h":
									components.gl = 1;
									components.ha = 1;
									break;
								case "i":
									components.gl = 2;
									break;
								case "j":
									components.gl = 1;
									components.dl = 1;
									components.ha = 1;
									break;
								case "k":
									components.gl = 2;
									components.c = 1;
									break;
								case "l":
									components.dl = 1;
									components.va = 1;
									break;
								case "m":
									components.va = 2;
									break;
								case "n":
									components.gl = 1;
									components.dl = 1;
									break;
								case "o":
									components.c = 1;
									break;
								case "p":
									components.c = 2;
									break;
								case "q":
									components.gl = 1;
									components.va = 2;
									break;
								case "r":
									components.gl = 1;
									components.c = 1;
									break;
								case "s":
									components.gl = 1;
									components.va = 1;
									break;
								case "t":
									components.va = 1;
									break;
								case "u":
									components.dl = 1;
									components.ha = 1;
									break;
								case "v":
									components.gl = 1;
									components.dl = 2;
									break;
								case "w":
									components.gl = 2;
									components.dl = 1;
									break;
								case "x":
									components.gl = 1;
									components.dl = 1;
									components.va = 1;
									break;
								case "y":
									components.gl = 2;
									components.va = 1;
									break;
								case "z":
									components.gl = 1;
									components.ha = 2;
									break;
								case ".":
									components.dl = 3;
									break;
								case ",":
									components.dl = 2;
									components.va = 1;
									break;
								case "'":
									components.dl = 2;
									components.ha = 1;
									break;
								case "?":
									components.dl = 2;
									components.c = 1;
									break;
								case "(":
									components.dl = 1;
									components.va = 2;
									break;
								case ")":
									components.va = 3;
									break;
								case "!":
									components.gl = 1;
									components.dl = 1;
									components.c = 1;
									break;
								case ":":
									components.dl = 1;
									components.c = 2;
									break;
								case ";":
									components.dl = 1;
									components.ha = 2;
									break;
								case "-":
									components.c = 3;
									break;
								case "/":
									components.ha = 3;
									break;
								case '"':
									components.gl = 5;
									break;
								case "0":
									components.gl = 2;
									components.vl = 2;
									break;
								case "1":
									components.gl = 4;
									break;
								case "2":
									components.gl = 3;
									components.dl = 1;
									break;
								case "3":
									components.gl = 3;
									components.va = 1;
									break;
								case "4":
									components.gl = 3;
									components.ha = 1;
									break;
								case "5":
									components.gl = 3;
									components.c = 1;
									break;
								case "6":
									components.gl = 2;
									components.dl = 2;
									break;
								case "7":
									components.gl = 2;
									components.dl = 1;
									components.va = 1;
									break;
								case "8":
									components.gl = 2;
									components.dl = 1;
									components.ha = 1;
									break;
								case "9":
									components.gl = 2;
									components.dl = 1;
									components.c = 1;
									break;
								default:
									components.gl = 5;
							}
						} else if (S.getType(character) == "Array") {
							if (odd) {
								S.forEach(character, function (component) {
									if (component.size != "small") {
										components[component.type] += 1;
									}
								});
							} else {
								S.forEach(character, function (component) {
									if (component.size == "small") {
										components[component.type] += 1;
									}
								});
							}
						} else {
							throw new TypeError("The character provided was an incorrect type.");
						}
						S.forEach(components, function (amount, type) {
							if (amount > 0) {
								S.forEach(amount, function () {
									let component = {};
									component.type = type;
									if (odd) {
										if (Math.round(Math.random())) {
											component.size = "big";
										} else {
											component.size = "biggest";
										}
									} else {
										component.size = "small";
									}
									component.variation = Math.round(Math.random());
									let dimensions = getDimensions(component.type, component.size, component.variation);
									let width = dimensions[0];
									let height = dimensions[1];
									let wr = 0;  // wiggle room
									if (-1 <= width && width <= 1) {
										wr = 1;
									} else {
										wr = 2;
									}
									if (width >= 0) {
										if (height >= 0) {
											component.coords = [
												Math.round((9 - width) * Math.random()),
												Math.round((4 - height) * Math.random())
											];
											if (component.coords[0] > 4 + wr - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 - height) * Math.random())
												];
											}
											if (component.coords[0] > 4 + wr + 1 - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 - height) * Math.random())
												];
											}
										} else {
											component.coords = [
												Math.round((9 - width) * Math.random()),
												Math.round((4 + height) * Math.random() - height)
											];
											if (component.coords[0] > 4 + wr - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 + height) * Math.random() - height)
												];
											}
											if (component.coords[0] > 4 + wr + 1 - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 + height) * Math.random() - height)
												];
											}
										}
									} else {
										if (height >= 0) {
											component.coords = [
												Math.round((9 + width) * Math.random() - width),
												Math.round((4 - height) * Math.random())
											];
											if (component.coords[0] > 4 + wr) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 - height) * Math.random())
												];
											}
											if (component.coords[0] > 4 + wr + 1) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 - height) * Math.random())
												];
											}
										} else {
											component.coords = [
												Math.round((9 + width) * Math.random() - width),
												Math.round((4 + height) * Math.random() - height)
											];
											if (component.coords[0] > 4 + wr) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 + height) * Math.random() - height)
												];
											}
											if (component.coords[0] > 4 + wr + 1) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 + height) * Math.random() - height)
												];
											}
										}
									}
									symbol.push(component);
								});
							}
						});
						if (!odd) {
							if (indexToReplace === undefined) {
								symbols.push(symbol);
							} else {
								symbols[indexToReplace] = symbol;
							}
							drawSymbol(symbolToReplace, indexToReplace);
							odd = !odd;
						} else if (S.getType(character) == "Array") {
							odd = !odd;
							createSubsymbol(character, symbolToReplace, indexToReplace);
						} else {
							odd = !odd;
						}
					}
					S.forEach(message, function (character) {
						if (character.search(/[A-Z]/) > -1) {  // if it's a capital
							createSubsymbol(null);
							createSubsymbol(character.toLowerCase());
						} else {
							createSubsymbol(character);
						}
					});
					if (!odd) {
						symbols.push(symbol);
						drawSymbol();
					}
				}
			});
			S.listen("symbolSize", "change", function () {
				S.forEach(S.getId("encrypted3").getElementsByTagName("img"), function (img, index) {
					symbol = symbols[index];
					drawASymbol(img, index);
				});
			});
			S.listen("symbolWindow", "click", function () {
				if (S.getId("encrypted3").innerHTML != "") {
					let symbolWindow = window.open();
					if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {  // if the dark theme is being used
						symbolWindow.document.body.style = "background: black";
					}
					S.forEach(S.getId("encrypted3").getElementsByTagName("img"), function (img) {
						let newImg = img.cloneNode();
						newImg.style.margin = Number(S.getId("symbolSize").value) / 2 + "px";
						symbolWindow.document.body.appendChild(newImg);
					});
				}
			});



			// handles math code stuff

			S.listen("decrypted4", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			S.listen("encrypted4", ["dblclick", "touchhold"], function () {
				this.value = "";
			});
			/*
			S.listen("decrypted4", "keyup", function () {
				if (this.value.trim() == "") {
					S.getId("encrypted4").innerHTML = '<span style="color:gray">Encoded text</span>';
				}
			});
			*/
			S.listen("encrypted4", "focus", function () {
				if (this.innerHTML.trim() == '<span style="color:gray">Encoded text</span>') {
					/// Has to use "color:gray" in quotation marks (not apostrophies) or else  it will evaluate false
					/// (Doesn't matter whether "color:gray" is in quotation marks or not in the HTML)
					this.innerHTML = "";
				}
			});
			S.listen("encrypted4", "blur", function () {
				if (this.innerHTML.trim() == "") {
					this.innerHTML = '<span style="color:gray">Encoded text</span>';
				}
			});
			S.listen("encode4", "click", function () {
				if (S.getId("decrypted4").value.trim() != "") {  // if encoding
					// establishes which mathematical symbols to use
					let times = "";
					if (S.getName("multiplicationSign", true).id == "HTMLMultiply") {
						times = "&times;";
					} else {
						times = "*";
					}
					let divide = "";
					if (S.getName("divisionSign", true).id == "HTMLDivide") {
						divide = "&divide;";
					} else {
						divide = "/";
					}
					let exponent = "";
					if (S.getName("exponentSign", true).id == "HTMLExponent") {
						exponent = "<sup>";
					} else {
						exponent = "^";
					}
					let pi = "";
					if (S.getName("piSign", true).id == "HTMLPi") {
						pi = "&pi;";
					} else {
						pi = "pi";
					}

					let text = S.getId("decrypted4").value;
					// converts some things without code representations into things that can be encoded
					text = text.replace(/&/g, "and");
					text = text.replace(/%/g, " percent");
					text = text.replace(/$(\d+(?:\.\d+)?)/g, "$1 dollars");
					// preformats the text
					text = text.replace(/^[A-Z]/, function (match) { return match.toLowerCase(); });  // gets rid of initial capitals
					text = text.replace(/  ([A-Z])/g, "$1");  // capitals preceded by two spaces stay capital
					text = text.replace(/  +/g, " ");  // any amount of spaces is condensed into one space
					text = text.replace(/ I/g, " i");  // the word "I" isn't capitalized
					text = text.replace(/, ([A-Z])/g, ",$1");  // preserves intended capitals after commas
					text = text.replace(/(\W) ([a-zA-Z])/g, function (_, punctuation, capital) { return punctuation+capital.toLowerCase(); });
					text = text.replace(/([a-z])([A-Z])/g, "$1 $2");  // makes sure intended capitals aren't mushed into other words
					text = text.replace(/^t/, " t");  // makes it so the letter "t" is processed correctly at the beginning of the text
					text = text.replace(/^([k-sK-S])/, " $1");  // makes sure the middle of the alphabet is processed correctly at the beginning
					text = text.replace(/(\d),(\d)/g, "$1$2");  // gets rid of commas within large numbers
					text = text.replace(/~/g, "-9.20+92+4+5~");  // encodes any tildes since they're used for processing elsewhere
					// determines exactly how to represent a letter
					function convertToNumber(letter, number) {
						let replacement = number;
						if (letter.includes(" ")) {  // if it begins a word
							if (replacement.includes("+")) {
								replacement = times + replacement.slice(1);
							} else if (replacement.includes("-")) {
								replacement = divide + replacement.slice(1);
							} else {
								replacement = "." + replacement;
							}
						}
						if (letter != letter.toLowerCase()) {  // if it's supposed to be a capital
							replacement += pi;
						}
						return replacement;
					}
					// replaces the input text with encoded text
					text = text.replace(/\d+| [A-Za-z]|[a-z]|./g, function (match) {
						let replacement = "";
						if (match.search(/\d+/) > -1) {  // if it's a number
							replacement = "-8." + match;
						} else if (match.search(/[A-Za-z]/) > -1) {  // if it's a letter (possibly preceded by a space)
							switch (match.toLowerCase().trim()) {
								case "a":
									replacement = convertToNumber(match, "+1");
									break;
								case "b":
									replacement = convertToNumber(match, "+2");
									break;
								case "c":
									replacement = convertToNumber(match, "+3");
									break;
								case "d":
									replacement = convertToNumber(match, "+4");
									break;
								case "e":
									replacement = convertToNumber(match, "+5");
									break;
								case "f":
									replacement = convertToNumber(match, "+6");
									break;
								case "g":
									replacement = convertToNumber(match, "+7");
									break;
								case "h":
									replacement = convertToNumber(match, "+8");
									break;
								case "i":
									replacement = convertToNumber(match, "+9");
									break;
								case "j":
									replacement = convertToNumber(match, "-7");
									break;
								case "k":
									replacement = convertToNumber(match, "1");
									break;
								case "l":
									replacement = convertToNumber(match, "2");
									break;
								case "m":
									replacement = convertToNumber(match, "3");
									break;
								case "n":
									replacement = convertToNumber(match, "4");
									break;
								case "o":
									replacement = convertToNumber(match, "5");
									break;
								case "p":
									replacement = convertToNumber(match, "6");
									break;
								case "q":
									replacement = convertToNumber(match, "7");
									break;
								case "r":
									replacement = convertToNumber(match, "8");
									break;
								case "s":
									replacement = convertToNumber(match, "9");
									break;
								case "t":
									if (match.includes(" ")) {
										replacement = "-8";
									} else {
										replacement = "0";
									}
									if (match.toLowerCase() != match) {
										replacement += pi;
									}
									break;
								case "u":
									replacement = convertToNumber(match, "-1");
									break;
								case "v":
									replacement = convertToNumber(match, "-2");
									break;
								case "w":
									replacement = convertToNumber(match, "-3");
									break;
								case "x":
									replacement = convertToNumber(match, "-4");
									break;
								case "y":
									replacement = convertToNumber(match, "-5");
									break;
								case "z":
									replacement = convertToNumber(match, "-6");
									break;
							}
						} else {  // if it's punctuation
							switch (match) {
								case ",":
									if (exponent == "^") {
										replacement = "^4";
									} else {
										replacement = "<sup>4</sup>";
									}
									break;
								case "'":
									if (exponent == "^") {
										replacement = "^5";
									} else {
										replacement = "<sup>5</sup>";
									}
									break;
								case ".":
									if (exponent == "^") {
										replacement = "^6";
									} else {
										replacement = "<sup>6</sup>";
									}
									break;
								case "?":
									if (exponent == "^") {
										replacement = "^7";
									} else {
										replacement = "<sup>7</sup>";
									}
									break;
								case "!":
									if (exponent == "^") {
										replacement = "^8";
									} else {
										replacement = "<sup>8</sup>";
									}
									break;
								case "(":
									replacement = divide + "8";
									break;
								case ")":
									replacement = divide + "9";
									break;
								case "-":
									replacement = "-9.08-56+8+54~";
									break;
								case "/":
									replacement = "-9.192+19+8~";
									break;
								case ":":
									replacement = "-9.035254~";
									break;
								case ";":
									replacement = "-9.19+53+9+35254~";
									break;
								case '"':
									replacement = "-9.17-150+1+954-9.13+181~";
									break;
								case "&":
									replacement = "-9.0136+589+14+4~";
									break;
								case "+":
									replacement = "-9.162-19~";
									break;
								case "=":
									replacement = "-9.057-1+129~";
									break;
								case "*":
									replacement = "-9.0190+58+991~";
									break;
								case "^":
									replacement = "-9.03+18+50~";
									break;
								case "_":
									replacement = "-9.214+4+589+358+5~";
									break;
								case "%":
									replacement = "-9.16+58+3+540~";
									break;
								case "$":
									replacement = "-9.04522+18-9.19+9+74~";
									break;
								case "#":
									replacement = "-9.14-13+2+58-9.19+9+74~";
									break;
								case "@":
									replacement = "-9.010-9.19+9+74~";
									break;
								case "[":
									replacement = "-9.156+54+94+7-9.028+1+31+50~";
									break;
								case "]":
									replacement = "-9.03259+94+7-9.028+1+31+50~";
									break;
								case "{":
									replacement = "-9.156+54+94+7-9.03-182-5-9.028+1+3+5~";
									break;
								case "}":
									replacement = "-9.03259+94+7-9.03-182-5-9.028+1+3+5~";
									break;
								case "<":
									replacement = "-9.12+599-9.20+8+14-9.19+9+74~";
									break;
								case ">":
									replacement = "-9.078+5+10+58-9.20+8+14-9.19+9+74~";
									break;
								default:
									replacement = match;
							}
						}
						return replacement;
					});
					// catches any unexpected spaces
					text = text.replace(/~\+/g, times);
					text = text.replace(/~-/g, divide);
					text = text.replace(/~(\d)/g, ".$1");
					// condenses some of the math
					text = text.replace(/\+\d-\d(?!\d|\.|^|<)|-\d\+\d(?!\d|\.|^|<)/g, function (match) {
						let sign = match[0];
						let number1 = match[1];
						let number2 = match[3];
						if (number1 == number2) {
							if (exponent == "^") {
								return sign + number1 + "^2";
							} else {
								return sign + number1 + "<sup>2</sup>";
							}
						} else {
							return match;
						}
					});
					// catches when the previous replacement partially overlapped with what should've been replaced
					text = text.replace(/((?:\+|-)\d)(\+\d-\d(?!\d|\.|^|<)|-\d\+\d(?!\d|\.|^|<))/g, function (entirety, annoyance, match) {
						let sign = match[0];
						let number1 = match[1];
						let number2 = match[3];
						if (number1 == number2) {
							if (exponent == "^") {
								return annoyance + sign + number1 + "^2";
							} else {
								return annoyance + sign + number1 + "<sup>2</sup>";
							}
						} else {
							return entirety;
						}
					});
					// cleans up any other irregularities
					text = text.replace(/^\+|~$/, "");  // gets rid of processing artefacts from the beginning and end of the text
					text = text.replace(/~/g, "");  // gets rid of any lingering tildes (likely only remaining if there's an error)
					text = text.replace(/^\./, "0.");  // makes sure the middle of the alphabet displays correctly at the beginning
					text = text.replace(/(\^\d|<sup>\d)(<\/sup>)?(?:\^|<sup>)(\d)(?:<\/sup>)?/g, "$1$3$2");  // prevents back-to-back exponents
					text = text.replace(/(\)|&pi;|pi|<\/sup>)(\d)/g, "$1-0.$2");  // prevents numbers from being mushed together in an unnatural way
					text = text.replace(/(\D)\.(\d)/g, "$1+0.$2");  // makes sure the encoding doesn't put a decimal in an unnatural place
					text = text.replace(/(\d+\.\d+)\./g, "$1+0.");  // makes sure no number has two decimals in it
					text = text.replace(/ /g, "");  // gets rid of any spaces
					text = text.replace(/-|\+/g, "<wbr>$&");  // makes sure new lines are started in sensible places
					// displays the encrypted text
					S.getId("encrypted4").innerHTML = text;

				} else if (S.getId("encrypted4").innerHTML.trim() != "") {  // if decoding
					let tokens = S.getId("encrypted4").innerHTML;
					tokens = tokens.replace(/ /g, "");  // gets rid of all spaces
                                        tokens = tokens.replace(/<br>/g, "\n\r");  // makes new lines display better
					tokens = tokens.replace(/<sup>(\d+(?:\.\d+)?)<\/sup>/g, "^$1");  // turns superscript notation into caret notation
					tokens = tokens.replace(/<wbr>/g, "");  // gets rid of any potential HTML word breaks
					tokens = tokens.replace(/^([1-9])/, "+$1");  // makes sure the beginning of the alphabet is processed correctly at the beginning
					tokens = tokens.replace(/^0./, "");  // makes sure the middle of the alphabet is processed correctly at the beginning
					tokens = tokens.match(/&[^;]+?;|\D|\d/g);
					let text = "";
					let index = 0;
					while (index < tokens.length) {
						let token = tokens[index];
						let next = tokens[index + 1];
						let third = tokens[index + 2];
						switch (token) {
							case "+":
								if (next == "0") {
									index += 2;
								} else {
									if (third == "pi" || third == "&pi;" || third == "\u03C0") {
										text += ["A", "B", "C", "D", "E", "F", "G", "H", "I"][Number(next) - 1];
										index += 3;
									} else {
										text += ["a", "b", "c", "d", "e", "f", "g", "h", "i"][Number(next) - 1];
										index += 2;
									}
								}
								break;
							case "-":
								if (next == 0) {
									index += 3;
								} else if (next == "8") {
									if (third == "pi" || third == "&pi;" || third == "\u03C0") {
										text += " T";
										index += 3;
									} else if (third == ".") {  // if it's supposed to be a number
										index += 3;
										text += " ";
										while (tokens[index] !== undefined && tokens[index].search(/^\d+$/) > -1) {
											text += tokens[index];
											index++;
										}
									} else {
										text += " t";
										index += 2;
									}
								} else if (next == "9") {  ////
									index += 2;
								} else {
									if (third == "pi" || third == "&pi;" || third == "\u03C0") {
										text += ["U", "V", "W", "X", "Y", "Z", "J"][Number(next) - 1];
										index += 3;
									} else {
										text += ["u", "v", "w", "x", "y", "z", "j"][Number(next) - 1];
										index += 2;
									}
								}
								break;
							case "*":
							case "&times;":
							case "\u00D7":
								if (third == "pi" || third == "&pi;" || third == "\u03C0") {
									text += " " + ["A", "B", "C", "D", "E", "F", "G", "H", "I"][Number(next) - 1];
									index += 3;
								} else {
									text += " " + ["a", "b", "c", "d", "e", "f", "g", "h", "i"][Number(next) - 1];
									index += 2;
								}
								break;
							case "/":
							case "&divide;":
							case "\u00F7":
								if (next == "8") {
									text += " (";
									index += 2;
								} else if (next == "9") {
									text += ") ";
									index += 2;
								} else {
									if (third == "pi" || third == "&pi;" || third == "\u03C0") {
										text += " " + ["U", "V", "W", "X", "Y", "Z", "J"][Number(next) - 1];
										index += 3;
									} else {
										text += " " + ["u", "v", "w", "x", "y", "z", "j"][Number(next) - 1];
										index += 2;
									}
								}
								break;
							case "^":
								if (next != "5" && third && third.search(/^\d$/) > -1) {  // if there's more than one number in the exponent
									tokens = tokens.slice(0, index + 2).concat("^", tokens.slice(index + 2));
								}
								switch (next) {
									case "2":
										tokens[index + 1] = tokens[index - 1];
										if (tokens[index - 2] == "+") {
											tokens[index] = "-";
										} else if (tokens[index - 2] == "-") {
											tokens[index] = "+";
										} else {  // if something weird happened, and you just need to move on
											index += 2;
										}
										/*
										if (tokens[index - 2] == "*" || tokens[index - 2] == "&times;" || tokens[index - 2] == "\u00D7") {
											tokens[index] = "*";
										} else if (tokens[index - 2] == "/" || tokens[index - 2] == "&divide;" || tokens[index - 2] == "\u00F7") {
											tokens[index] = "/";
										} else {

										}
										*/
										break;
									case "3":  ////
										index += 2;
										break;
									case "4":
										text += ",";
										index += 2;
										break;
									case "5":
										text += "'";
										index += 2;
										break;
									case "6":
										text += ".";
										index += 2;
										break;
									case "7":
										text += "?";
										index += 2;
										break;
									case "8":
										text += "!";
										index += 2;
										break;
									default:
										index += 2;
								}
								break;
							case "0":
							case "1":
							case "2":
							case "3":
							case "4":
							case "5":
							case "6":
							case "7":
							case "8":
							case "9":
								if (next == "pi" || next == "&pi;" || next == "\u03C0") {
									text += ["T", "K", "L", "M", "N", "O", "P", "Q", "R", "S"][Number(token)];
									index += 2;
								} else {
									text += ["t", "k", "l", "m", "n", "o", "p", "q", "r", "s"][Number(token)];
									index++;
								}
								break;
							case ".":
								if (third == "pi" || third == "&pi;" || third == "\u03C0") {
									text += " " + ["T", "K", "L", "M", "N", "O", "P", "Q", "R", "S"][Number(next)];
									index += 3;
								} else {
									text += " " + ["t", "k", "l", "m", "n", "o", "p", "q", "r", "s"][Number(next)];
									index += 2;
								}
								break;
							default:
								text += token;
								index++;
						}
					}
					text = text.trim();
					text = text[0].toUpperCase() + text.slice(1);  // capitalizes the first letter of the first sentence
					text = text.replace(/(?:\.|\?|!)\w/g, function (match) {  // makes sure new sentences start with a space and a capital
						return match[0] + " " + match[1].toUpperCase();
					});
					text = text.replace(/(,|:|\)|;|")(\w)/g, "$1 $2");  // makes sure other punctuation has a space after it
					text = text.replace(/(^| )i(\W|$)/g, "$1I$2");  // makes the word "I" capitalized
					S.getId("decrypted4").value = text;
				}
			});



			S.onLoad(function () {
				S.makeToneGenerator(true);
			});
		</script>
		<link rel="stylesheet" href="https://epicenterprograms.github.io/standards/formatting/foundation.css">
		<style>
			#morseCodeSpeed {
				width: 2em;
			}
			#substitutedText {
				width: 15rem;
				height: 8rem;
			}
			#decrypted3 {
				width: 15em;
				height: 9em;
			}
			#encrypted3 {
				border: .05em solid gray;
				padding: .5em;
				width: 15em;
				height: 9em;
				text-align: left;
				overflow: auto;
			}
			#encrypted3 img, #encrypted3 canvas {
				display: inline;
				margin: .25em .5em;
			}
			#encrypted4 {
				border: .05em solid gray;
				padding: .5em;
				width: 15em;
				height: 8em;
				text-align: left;
				overflow: auto;
			}

			@font-face {
				font-family: "Bad Duck";
				src: url("fonts/Bad Duck.ttf") format("truetype");
			}
			@font-face {
				font-family: "KidtEnuhf";
				src: url("fonts/KidtEnuhf.ttf") format("truetype");
			}

			@media (max-width: 1000px) {
				#substitutedText {
					width: 45rem;
					height: 24rem;
				}
			}
		</style>
	</head>
	<body>
		<h1 class="main-title">
			Extras
		</h1>
		<main>
			<button onclick='window.location.href = "."'>
				Back
			</button>
			<section>
				Maybe you've come here in a desperate attempt to find a way of getting around the short-comings of the main decoder or maybe you were just curious after the decoder did its job; regardless, this is primarily just a place for random code-related fun. Feel free to explore.
			</section>
			<h2>
				Morse Code
			</h2>
			<input type="text" id="morseCodeText">
			<button onclick="toMorseCode()">
				Translate to Morse Code
			</button>
			Speed:
			<input type="text" id="morseCodeSpeed" value="15">
			<br>
			<button id="randomMorseCode">
				Make a random message in Morse Code
			</button>
			<h2>
				Code fonts
			</h2>
			<textarea id="substitutedText" placeholder="Text" spellcheck="false"></textarea>
			<br>
			<input type="radio" name="fonts" id="normalFont" checked><label for="normalFont">Normal</label>
			<input type="radio" name="fonts" id="badDuckFont"><label for="badDuckFont">Bad Duck</label>
			<input type="radio" name="fonts" id="kidtenuhfFont"><label for="kidtenuhfFont">KidtEnuhf</label>
			<br>
			Font size: <div style="background:#cccccc; border-radius:.25em"><input type="range" id="fontSize" min=".5" max="3" step=".1" value="1"></div>
			<br>
			<input type="checkbox" id="checkSpelling"><label for="checkSpelling">Check spelling</label>
			<br>
			Access help for
			<select id="fontHelp">
				<option value="" selected>None</option>
				<option value="Bad Duck">Bad Duck</option>
				<option value="KidtEnuhf">KidtEnuhf</option>
			</select>
			<aside id="badDuckHelp" data-heading="Bad Duck">
				The first column is the letter you want to produce; the second column is the encoded letter produced by pressing that key; the third column is the letter you press to get the decoded symbol; and the fourth column is the decoded symbol you get after pressing the key in the third column. Some symbols don't have a decoded version, so they only fill the first two columns. Some keys don't produce the expected output when you press them (e.g. "!" produces "<span style="font-family:Bad Duck">!</span>" when pressed rather than the symbol for the exclamation point), so they have 3 filled columns: one for the letter/character you want, one for the key you have to press to get that letter/character, and one showing what the output is. <span class="elaborate">[Why does that happen?]</span> The "[cap. 1]" and the others like it refer to types of capitalization. When you want to capitalize the first letter of a word, use "[cap. 1]" just before that letter; when you want to capitalize a whole word, use "[cap. 2]" just before that word; when you want to capitalize things in any other way, use a "[cap. 3]" before the start of your capitalization, and use another "[cap. 3]" when you're finished capitalizing. Only proper names should be capitalized, not beginnings of sentences or "I". Also, spaces are only needed when there isn't punctuation. (e.g. Don't separate two sentences with a period <em>and</em> a space.)
				<aside data-heading="Reasoning">
					When I was making this font, I wanted the capital letters to be the decoded versions of the lowercase letters (technically, there are only lowercase letters and capitalization indicators), and that worked out great for all of the letters, and I was even able to extend it to the numbers (the symbol you would get when you hold [shift] and press a number key on a standard keyboard). The only problem is that the "capitals" of the numbers are actually different symbols you might want to use for something else, so I had to work around that. Some of you may think that I should've left the numbers out of my decoding by capitalization, and maybe I'll change it in the future, but I liked the concept, and since I'm not motivated to make Bad Duck symbols for every single weird character on the keyboard, there were keys for me to work with.
				</aside>
				<table>
					<tr>
						<th>Letter</th>
						<th>Symbol</th>
						<th>Letter</th>
						<th>Symbol</th>
					</tr>
					<tr>
						<td>a</td>
						<td style="font-family:Bad Duck">a</td>
						<td>A</td>
						<td style="font-family:Bad Duck">A</td>
					</tr>
					<tr>
						<td>b</td>
						<td style="font-family:Bad Duck">b</td>
						<td>B</td>
						<td style="font-family:Bad Duck">B</td>
					</tr>
					<tr>
						<td>c</td>
						<td style="font-family:Bad Duck">c</td>
						<td>C</td>
						<td style="font-family:Bad Duck">C</td>
					</tr>
					<tr>
						<td>d</td>
						<td style="font-family:Bad Duck">d</td>
						<td>D</td>
						<td style="font-family:Bad Duck">D</td>
					</tr>
					<tr>
						<td>e</td>
						<td style="font-family:Bad Duck">e</td>
						<td>E</td>
						<td style="font-family:Bad Duck">E</td>
					</tr>
					<tr>
						<td>f</td>
						<td style="font-family:Bad Duck">f</td>
						<td>F</td>
						<td style="font-family:Bad Duck">F</td>
					</tr>
					<tr>
						<td>g</td>
						<td style="font-family:Bad Duck">g</td>
						<td>G</td>
						<td style="font-family:Bad Duck">G</td>
					</tr>
					<tr>
						<td>h</td>
						<td style="font-family:Bad Duck">h</td>
						<td>H</td>
						<td style="font-family:Bad Duck">H</td>
					</tr>
					<tr>
						<td>i</td>
						<td style="font-family:Bad Duck">i</td>
						<td>I</td>
						<td style="font-family:Bad Duck">I</td>
					</tr>
					<tr>
						<td>j</td>
						<td style="font-family:Bad Duck">j</td>
						<td>J</td>
						<td style="font-family:Bad Duck">J</td>
					</tr>
					<tr>
						<td>k</td>
						<td style="font-family:Bad Duck">k</td>
						<td>K</td>
						<td style="font-family:Bad Duck">K</td>
					</tr>
					<tr>
						<td>l</td>
						<td style="font-family:Bad Duck">l</td>
						<td>L</td>
						<td style="font-family:Bad Duck">L</td>
					</tr>
					<tr>
						<td>m</td>
						<td style="font-family:Bad Duck">m</td>
						<td>M</td>
						<td style="font-family:Bad Duck">M</td>
					</tr>
					<tr>
						<td>n</td>
						<td style="font-family:Bad Duck">n</td>
						<td>N</td>
						<td style="font-family:Bad Duck">N</td>
					</tr>
					<tr>
						<td>o</td>
						<td style="font-family:Bad Duck">o</td>
						<td>O</td>
						<td style="font-family:Bad Duck">O</td>
					</tr>
					<tr>
						<td>p</td>
						<td style="font-family:Bad Duck">p</td>
						<td>P</td>
						<td style="font-family:Bad Duck">P</td>
					</tr>
					<tr>
						<td>q</td>
						<td style="font-family:Bad Duck">q</td>
						<td>Q</td>
						<td style="font-family:Bad Duck">Q</td>
					</tr>
					<tr>
						<td>r</td>
						<td style="font-family:Bad Duck">r</td>
						<td>R</td>
						<td style="font-family:Bad Duck">R</td>
					</tr>
					<tr>
						<td>s</td>
						<td style="font-family:Bad Duck">s</td>
						<td>S</td>
						<td style="font-family:Bad Duck">S</td>
					</tr>
					<tr>
						<td>t</td>
						<td style="font-family:Bad Duck">t</td>
						<td>T</td>
						<td style="font-family:Bad Duck">T</td>
					</tr>
					<tr>
						<td>u</td>
						<td style="font-family:Bad Duck">u</td>
						<td>U</td>
						<td style="font-family:Bad Duck">U</td>
					</tr>
					<tr>
						<td>v</td>
						<td style="font-family:Bad Duck">v</td>
						<td>V</td>
						<td style="font-family:Bad Duck">V</td>
					</tr>
					<tr>
						<td>w</td>
						<td style="font-family:Bad Duck">w</td>
						<td>W</td>
						<td style="font-family:Bad Duck">W</td>
					</tr>
					<tr>
						<td>x</td>
						<td style="font-family:Bad Duck">x</td>
						<td>X</td>
						<td style="font-family:Bad Duck">X</td>
					</tr>
					<tr>
						<td>y</td>
						<td style="font-family:Bad Duck">y</td>
						<td>Y</td>
						<td style="font-family:Bad Duck">Y</td>
					</tr>
					<tr>
						<td>z</td>
						<td style="font-family:Bad Duck">z</td>
						<td>Z</td>
						<td style="font-family:Bad Duck">Z</td>
					</tr>
					<tr>
						<td>[space]</td>
						<td style="font-family:Bad Duck">&nbsp;</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>0</td>
						<td style="font-family:Bad Duck">0</td>
						<td>)</td>
						<td style="font-family:Bad Duck">)</td>
					</tr>
					<tr>
						<td>1</td>
						<td style="font-family:Bad Duck">1</td>
						<td>!</td>
						<td style="font-family:Bad Duck">!</td>
					</tr>
					<tr>
						<td>2</td>
						<td style="font-family:Bad Duck">2</td>
						<td>@</td>
						<td style="font-family:Bad Duck">@</td>
					</tr>
					<tr>
						<td>3</td>
						<td style="font-family:Bad Duck">3</td>
						<td>#</td>
						<td style="font-family:Bad Duck">#</td>
					</tr>
					<tr>
						<td>4</td>
						<td style="font-family:Bad Duck">4</td>
						<td>$</td>
						<td style="font-family:Bad Duck">$</td>
					</tr>
					<tr>
						<td>5</td>
						<td style="font-family:Bad Duck">5</td>
						<td>%</td>
						<td style="font-family:Bad Duck">%</td>
					</tr>
					<tr>
						<td>6</td>
						<td style="font-family:Bad Duck">6</td>
						<td>^</td>
						<td style="font-family:Bad Duck">^</td>
					</tr>
					<tr>
						<td>7</td>
						<td style="font-family:Bad Duck">7</td>
						<td>&</td>
						<td style="font-family:Bad Duck">&</td>
					</tr>
					<tr>
						<td>8</td>
						<td style="font-family:Bad Duck">8</td>
						<td>*</td>
						<td style="font-family:Bad Duck">*</td>
					</tr>
					<tr>
						<td>9</td>
						<td style="font-family:Bad Duck">9</td>
						<td>(</td>
						<td style="font-family:Bad Duck">(</td>
					</tr>
					<tr>
						<td>.</td>
						<td style="font-family:Bad Duck">.</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>;</td>
						<td style="font-family:Bad Duck">;</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>,</td>
						<td style="font-family:Bad Duck">,</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>'</td>
						<td style="font-family:Bad Duck">'</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>:</td>
						<td style="font-family:Bad Duck">:</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>-</td>
						<td style="font-family:Bad Duck">-</td>
						<td></td>
						<td style="font-family:Bad Duck"></td>
					</tr>
					<tr>
						<td>/</td>
						<td style="font-family:Bad Duck">/</td>
						<td>&lt;</td>
						<td style="font-family:Bad Duck">&lt;</td>
					</tr>
					<tr>
						<td>?</td>
						<td style="font-family:Bad Duck">?</td>
						<td>&gt;</td>
						<td style="font-family:Bad Duck">&gt;</td>
					</tr>
					<tr>
						<td>!</td>
						<td style="font-family:Bad Duck"></td>
						<td>_</td>
						<td style="font-family:Bad Duck">_</td>
					</tr>
					<tr>
						<td>[cap. 1]</td>
						<td style="font-family:Bad Duck"></td>
						<td>\</td>
						<td style="font-family:Bad Duck">\</td>
					</tr>
					<tr>
						<td>[cap. 2]</td>
						<td style="font-family:Bad Duck"></td>
						<td>|</td>
						<td style="font-family:Bad Duck">|</td>
					</tr>
					<tr>
						<td>[cap. 3]</td>
						<td style="font-family:Bad Duck"></td>
						<td>`</td>
						<td style="font-family:Bad Duck">`</td>
					</tr>
					<tr>
						<td>(</td>
						<td style="font-family:Bad Duck"></td>
						<td>[</td>
						<td style="font-family:Bad Duck">[</td>
					</tr>
					<tr>
						<td>(</td>
						<td style="font-family:Bad Duck"></td>
						<td>{</td>
						<td style="font-family:Bad Duck">{</td>
					</tr>
					<tr>
						<td>)</td>
						<td style="font-family:Bad Duck"></td>
						<td>]</td>
						<td style="font-family:Bad Duck">]</td>
					</tr>
					<tr>
						<td>)</td>
						<td style="font-family:Bad Duck"></td>
						<td>}</td>
						<td style="font-family:Bad Duck">}</td>
					</tr>
				</table>
			</aside>
			<aside id="kidtenuhfHelp" data-heading="KidtEnuhf">
				The first column is the sound you want to represent; the second column is the letter you press to represent that sound; and the third column is the symbol produced by pressing that letter.
				<table>
					<tr>
						<th>Sound</th>
						<th>Letter</th>
						<th>Symbol</th>
					</tr>
					<tr>
						<td>a</td>
						<td>a</td>
						<td style="font-family:KidtEnuhf">a</td>
					</tr>
					<tr>
						<td>ae</td>
						<td>I</td>
						<td style="font-family:KidtEnuhf">I</td>
					</tr>
					<tr>
						<td>ah</td>
						<td>A</td>
						<td style="font-family:KidtEnuhf">A</td>
					</tr>
					<tr>
						<td>aw</td>
						<td>W</td>
						<td style="font-family:KidtEnuhf">W</td>
					</tr>
					<tr>
						<td>ay</td>
						<td>Y</td>
						<td style="font-family:KidtEnuhf">Y</td>
					</tr>
					<tr>
						<td>b</td>
						<td>b</td>
						<td style="font-family:KidtEnuhf">b</td>
					</tr>
					<tr>
						<td>ch</td>
						<td>c</td>
						<td style="font-family:KidtEnuhf">c</td>
					</tr>
					<tr>
						<td>d</td>
						<td>d</td>
						<td style="font-family:KidtEnuhf">d</td>
					</tr>
					<tr>
						<td>dh</td>
						<td>D</td>
						<td style="font-family:KidtEnuhf">D</td>
					</tr>
					<tr>
						<td>dt</td>
						<td>q</td>
						<td style="font-family:KidtEnuhf">q</td>
					</tr>
					<tr>
						<td>e</td>
						<td>e</td>
						<td style="font-family:KidtEnuhf">e</td>
					</tr>
					<tr>
						<td>ee</td>
						<td>E</td>
						<td style="font-family:KidtEnuhf">E</td>
					</tr>
					<tr>
						<td>f</td>
						<td>f</td>
						<td style="font-family:KidtEnuhf">f</td>
					</tr>
					<tr>
						<td>g</td>
						<td>g</td>
						<td style="font-family:KidtEnuhf">g</td>
					</tr>
					<tr>
						<td>h</td>
						<td>h</td>
						<td style="font-family:KidtEnuhf">h</td>
					</tr>
					<tr>
						<td>i</td>
						<td>i</td>
						<td style="font-family:KidtEnuhf">i</td>
					</tr>
					<tr>
						<td>j</td>
						<td>j</td>
						<td style="font-family:KidtEnuhf">j</td>
					</tr>
					<tr>
						<td>k</td>
						<td>k</td>
						<td style="font-family:KidtEnuhf">k</td>
					</tr>
					<tr>
						<td>l</td>
						<td>l</td>
						<td style="font-family:KidtEnuhf">l</td>
					</tr>
					<tr>
						<td>m</td>
						<td>m</td>
						<td style="font-family:KidtEnuhf">m</td>
					</tr>
					<tr>
						<td>n</td>
						<td>n</td>
						<td style="font-family:KidtEnuhf">n</td>
					</tr>
					<tr>
						<td>o</td>
						<td>o</td>
						<td style="font-family:KidtEnuhf">o</td>
					</tr>
					<tr>
						<td>oo</td>
						<td>O</td>
						<td style="font-family:KidtEnuhf">O</td>
					</tr>
					<tr>
						<td>p</td>
						<td>p</td>
						<td style="font-family:KidtEnuhf">p</td>
					</tr>
					<tr>
						<td>r</td>
						<td>r</td>
						<td style="font-family:KidtEnuhf">r</td>
					</tr>
					<tr>
						<td>rr</td>
						<td>R</td>
						<td style="font-family:KidtEnuhf">R</td>
					</tr>
					<tr>
						<td>s</td>
						<td>s</td>
						<td style="font-family:KidtEnuhf">s</td>
					</tr>
					<tr>
						<td>sh</td>
						<td>S</td>
						<td style="font-family:KidtEnuhf">S</td>
					</tr>
					<tr>
						<td>t</td>
						<td>t</td>
						<td style="font-family:KidtEnuhf">t</td>
					</tr>
					<tr>
						<td>th</td>
						<td>T</td>
						<td style="font-family:KidtEnuhf">T</td>
					</tr>
					<tr>
						<td>u</td>
						<td>u</td>
						<td style="font-family:KidtEnuhf">u</td>
					</tr>
					<tr>
						<td>uh</td>
						<td>U</td>
						<td style="font-family:KidtEnuhf">U</td>
					</tr>
					<tr>
						<td>v</td>
						<td>v</td>
						<td style="font-family:KidtEnuhf">v</td>
					</tr>
					<tr>
						<td>w</td>
						<td>w</td>
						<td style="font-family:KidtEnuhf">w</td>
					</tr>
					<tr>
						<td>[None]</td>
						<td>x</td>
						<td style="font-family:KidtEnuhf">x</td>
					</tr>
					<tr>
						<td>-</td>
						<td>-</td>
						<td style="font-family:KidtEnuhf">-</td>
					</tr>
					<tr>
						<td>y</td>
						<td>y</td>
						<td style="font-family:KidtEnuhf">y</td>
					</tr>
					<tr>
						<td>z</td>
						<td>z</td>
						<td style="font-family:KidtEnuhf">z</td>
					</tr>
					<tr>
						<td>zh</td>
						<td>Z</td>
						<td style="font-family:KidtEnuhf">Z</td>
					</tr>
					<tr>
						<td>ng</td>
						<td>N</td>
						<td style="font-family:KidtEnuhf">N</td>
					</tr>
					<tr>
						<td>too</td>
						<td>Q</td>
						<td style="font-family:KidtEnuhf">Q</td>
					</tr>
					<tr>
						<td>/</td>
						<td>/</td>
						<td style="font-family:KidtEnuhf">/</td>
					</tr>
					<tr>
						<td>ol</td>
						<td>L</td>
						<td style="font-family:KidtEnuhf">L</td>
					</tr>
					<tr>
						<td>az</td>
						<td>X</td>
						<td style="font-family:KidtEnuhf">X</td>
					</tr>
					<tr>
						<td>me</td>
						<td>M</td>
						<td style="font-family:KidtEnuhf">M</td>
					</tr>
					<tr>
						<td>[Bold]</td>
						<td>B</td>
						<td style="font-family:KidtEnuhf">B</td>
					</tr>
				</table>
			</aside>
			<br>
			<button id="reprintText">
				Open text in<br>
				a new window
			</button>
			<h2>
				Code generators
			</h2>
			<section>
				The following sections can be used to convert text into various codes. In places where the encrypted section is editable, code can be put in, and decrypted text will be the output. If both inputs are filled, encoding the decrypted text wins out. Double-clicking or touching and holding on an input will erase its text.
			</section>
			<h3>
				Password-protected encryption
			</h3>
			<input type="text" id="encryptionKey" placeholder="password">
			<br>
			<textarea id="decrypted2" placeholder="Decoded text"></textarea>
			<textarea id="encrypted2" placeholder="Encoded text" spellcheck="false"></textarea>
			<br>
			<input type="checkbox" id="advancedEncryption" checked><label for="advancedEncryption">Use advanced encryption</label>
			<br>
			<button id="encode2">
				Encode
			</button>
			<h3>
				Letter code
			</h3>
			<textarea id="decrypted1" placeholder="Decoded text"></textarea>
			<textarea id="encrypted1" placeholder="Encoded text" spellcheck="false"></textarea>
			<br>
			<button id="encode1">
				Encode
			</button>
			<h3>
				Math code
			</h3>
			<section>
				This will turn your text into what looks like a mathematical expression. Encoding is a little better than decoding, but it works pretty well both ways.
			</section>
			<input type="radio" name="multiplicationSign" id="HTMLMultiply" checked>
			<label for="HTMLMultiply">&times;</label>
			<input type="radio" name="multiplicationSign" id="asteriskMultiply">
			<label for="asteriskMultiply">*</label>
			<br>
			<input type="radio" name="divisionSign" id="HTMLDivide" checked>
			<label for="HTMLDivide">&divide;</label>
			<input type="radio" name="divisionSign" id="slashDivide">
			<label for="slashDivide">/</label>
			<br>
			<input type="radio" name="exponentSign" id="HTMLExponent">
			<label for="HTMLExponent">base<sup>exponent</sup></label>
			<input type="radio" name="exponentSign" id="caretExponent" checked>
			<label for="caretExponent">base^exponent</label>
			<br>
			<input type="radio" name="piSign" id="HTMLPi" checked>
			<label for="HTMLPi">&pi;</label>
			<input type="radio" name="piSign" id="wordPi">
			<label for="wordPi">pi</label>
			<br>
			<textarea id="decrypted4" placeholder="Decoded text"></textarea>
			<div class="generic-background" id="encrypted4" contenteditable><span style="color:gray">Encoded text</span></div>
			<br>
			<button id="encode4">
				Encode
			</button>
			<h3>
				Symbol code
			</h3>
			<section>
				This can change text into seemingly random symbols. Pressing "Encode" multiple times will give different symbols. The symbols in the output are pictures and can be saved and used elsewhere. (Maximum symbol size is recommended if the pictures will ever be enlarged.) Alternatively, the "Open symbols in a new window" button will open a new tab or window with the symbols displayed, and a screenshot can be taken. Due to the extreme complexity of preventing such an occurrence, there will undoubtedly be times when parts of a symbol overlap with themselves or the symbol is awkwardly arranged; As a means of combating this, it's possible to click on the undesirable symbol to rearrange its parts. There are no decoding capabilities at present because no one has time for image-recognition software. Sometimes, the symbol area randomly disappears when changing individual symbols at a large symbol-size; This can be corrected by changing the symbol size (and changing it back).
			</section>
			<textarea id="decrypted3" placeholder="Text"></textarea>
			<div class="generic-background" id="encrypted3"></div>
			<br>
			Symbol size: <div style="background:#cccccc; border-radius:.25em"><input type="range" id="symbolSize" min="6" max="90" step="6" value="24"></div>
			<br>
			<button id="encode3">
				Encode
			</button>
			<br>
			<button id="symbolWindow">Open symbols in<br>a new window</button>
		</main>
	</body>
</html>
